# Perl入学式 #4

## 今日の内容
- リファレンスの復習
- サブルーチン
- サブルーチンとリファレンス
- 正規表現
- 正規表現と置換

# リファレンスの復習

# サブルーチン

## サブルーチンとは?
- プログラムの中で, 意味や内容がまとまっている作業をひとかたまりにしたものを｢サブルーチン｣と呼びます.
- Perlにおける｢サブルーチン｣は, ｢関数｣とほぼ同義です.

## 組み込み関数
- Perlには, これまで使ってきた`print`や`join`など, Perlが提供する関数(組み込み関数)が用意されています
- サブルーチンを使うことで, `print`や`join`のように, ｢特定の処理をするコード｣をひとかたまりにして, 簡単に呼ぶことが出来るようになります.

## サブルーチンの定義
- それでは, 早速サブルーチンを定義していきましょう.
- 今回は, 末尾に自動的に改行(`\n`)を付与しながら文字列を表示する`say`というサブルーチンを定義してみます.

## サブルーチンの定義

    sub say {
        my $str = shift @_;
        print "$str\n";     
    }
    say("hello, world!"); # => hello, world![改行]

- それでは, 詳しく見て行きましょう.

## サブルーチンの定義
    sub say { ... }

- Perlでサブルーチンを定義する為には, `sub 関数名 { ... }`と書きます.
- 末尾の`}`の後に, `;`を書く必要はありません.
- 関数名として使える文字は大文字･小文字の英数字と, アンダースコア(`_`)です.
    - 但し, 関数名の先頭は英文字か`_`でなければなりません.

## サブルーチンの定義

    sub output_data { ... }

- 複数の単語で関数名を構築する時は, このように単語どうしを`_`で繋げる(スネークケース)場合が多いです.

## 練習問題

    sub hoge!    { ... }; 
    sub _hoge    { ... };
    sub 1hoge    { ... };
    sub hoge_123 { ... };

- この中で, 関数名として正しいものはいくつあるでしょう?

## 練習問題

    sub hoge!    { ... }; # => '!'は関数名に使えない
    sub _hoge    { ... };
    sub 1hoge    { ... }; # => 先頭は英字or'_'
    sub hoge_123 { ... };

- 正解は`_hoge`と`hoge_123`の｢2つ｣です.

## サブルーチンの呼び出し

    say('hoge');

- 定義したサブルーチンは, 定義した関数名の後ろに`()`を付けることで呼び出せます.
- サブルーチンに値(引数)を渡したい場合, `()`の中に書きます.
- `()`を使わずに, 先頭に`&`を付けて`&say`で呼びだすこともできますが, 古い書き方なので使わないようにしましょう.

## サブルーチンの引数 
    sub say {
        my $str = shift @_; # @_ => ('hoge')
        ...
    }
    say('hoge');

- サブルーチンに与えられた引数は, `@_`という配列(無名配列)に格納されます.
- 2行目では, `shift`を使って, この`@_`の先頭の要素を取得しています.
- このサブルーチンを`say('hoge');`のように呼んだ場合, `@_`の中身は`('hoge')`になるので, `$str`には`hoge`という文字列が入ります.

## サブルーチンの引数
    sub say {
        my $str = shift;
        ...
    }

- サブルーチンに与えられた引数が格納されている`@_`は, 省略することができます.
- その為, 2行目の`my $str = shift;`は, `my $str = shift @_;`と同じ意味になります.

## サブルーチン｢add｣

    sub sum {
        my ($left, $right) = @_;
        return $left + $right;
    }
    my $result = sum(2, 5);

- 次に, 2つの引数を受け取り, その和を返すサブルーチン`sum`を考えてみることにします.
- `sum`関数の定義と呼び出しは, このように書くことができます.

## サブルーチンの引数

    sub sum {
        my ($left, $right) = @_;
        ... 
    }
    my $result = sum(2, 5);

- サブルーチンに複数の引数が与えられた場合(この場合は`2`と`5`), サブルーチン側ではこのようにして受け取ることができます.
    - サブルーチンに複数の引数を与える時は, (配列のように)`,`で区切って渡します.

## サブルーチンの引数

    sub sum {
        my $left  = shift;
        my $right = shift;
        ... 
    }

- 先程の引数の受け取り方は, 上記のコードと同じ意味になります.

## サブルーチンの返り値

    sub sum {
        my ($left, $right) = @_;
        return $left + $right;
    }
    my $result = sum(2, 5);

- サブルーチンは, `return`を使うことで, 任意のデータを呼び出し元へ返すことができます.
    - この場合, `$left + $right`の計算結果が, 呼び出し元へ返され, `$result`に格納されます. 

## 複数個のreturn

    sub cond {
        my ($i, $j) = @_;
        if ($i == $j) {
            return 1;
        }
        return 0;
    }

- `return`はサブルーチンの中に複数個書くことができますが, `return`に到達した場合, それ以降の処理は一切行われず, すぐさま値を返してサブルーチンの実行を終了します.

## 複数の返り値

    sub calc {
        my ($left, $right) = @_;
        return ($left + $right, $left - $right);
    }
    my ($sum, $sub) = calc(5, 4);

- サブルーチンは, このようにリストを返すことで, 複数個の値を返すこともできます.

## returnがない場合の返り値

    sub sum {
        my ($left, $right) = @_;
        $left + $right;
    }

- サブルーチンの中に`return`がない場合, サブルーチンの返り値は, 最後に評価された処理の結果(この場合, `$left + $right`の計算結果)を返します.

## 練習問題
- 2つの引数の和を計算する'sum'と同様に, 2つの引数の差を計算する'sub', 積を計算する'mul', 商を計算する'div'という関数を作ってみよう.
- これらの関数が正しく実装できているか(与えた2つの引数に対して, 適切な値を返すか)を確認するコードを書いてみよう.

# サブルーチンとリファレンス

## 配列を引数に
    my @hoge = qw/ hoge fuga /;
    my @foo  = qw/ foo bar baz /;
    sub output {
        my (@array1, @array2) = @_;
        print '@array1 = ' . join(',', @array1) . "\n";  
        print '@array2 = ' . join(',', @array2) . "\n";  
    }
    output(@hoge, @foo);

- サブルーチンの引数として, 2つの配列を与えてみましょう.
    - この時, 実行結果はどうなると思いますか? 考えてみましょう.

## 配列を引数に

    @array1 = hoge,fuga,foo,bar,baz
    @array2 =

- 実行結果はこのようになります!

## 配列を引数に

    @array1 = hoge,fuga
    @array2 = foo,bar,baz

- このようになる, と予測した方は多いのではないでしょうか?

## なぜ!?

    my @array1 = qw/ hoge fuga /;
    my @array2 = qw/ foo bar baz /;
    my @array  = (@array1, @array2);
    # @array = ('hoge', 'fuga', 'foo', 'bar', 'baz');

- これは, 複数の配列をリストで評価すると, 展開されて元の配列の区別がなくなってしまう為です.
- 先程の場合, `@_`の中身は`('hoge', 'fuga', 'foo', 'bar', 'baz')になりますが, Perlは元の配列の`@hoge`と`@foo`の境目がどこにあるかわからないので, 全て`@array1`に突っ込もうとします.

## 更に...

- 配列を直接サブルーチンに与えた場合, Perlはその値を全てコピーしてから処理を行います.
- 配列の要素が数個なら問題ありませんが, 大量のデータがあったら, コピーに時間がかかってしまって大変なことになってしまいます.

## そこで!

- この問題を解決する為に, リファレンスを利用することができます!

## リファレンス渡し

    my @hoge = qw/ hoge fuga /;
    my @foo  = qw/ foo bar baz /;
    sub output {
        my ($array1, $array2) = @_;
        print '@$array1 = ' . join(',', @$array1) . "\n";  
        print '@$array2 = ' . join(',', @$array2) . "\n";  
    }
    output(\@hoge, \@foo);

- 8行目で配列のリファレンスを渡しているので, 4行目では2つのスカラ変数で引数を受け取っています.

## リファレンス渡し

    @$array1 = hoge,fuga
    @$array2 = foo,bar,baz

- 実行してみると, 期待通りの結果を取得することができました.

## リファレンス渡し

- 配列と同様に, ハッシュもリファレンスで渡すことができます.
- 更に, リファレンスで渡す場合, 配列をそのまま渡した時のように, データのコピーが発生しません.
- 引数として与えた配列･ハッシュの構造をそのままサブルーチンに渡すことができ, データのコピーが発生しない｢リファレンス渡し｣ですが, 1つ注意点があります.

## 中身の書き換え

    my %hash = { papix => 'dame' };
    print $hash{papix}; # => dame
    fix(\%hash);
    print $hash{papix}; # => perfect

    sub fix {
        my $hash = shift;
        $hash->{papix} = 'perfect';
    }

- サブルーチンに渡される配列･ハッシュのリファレンス(この場合, サブルーチン内の`$fix`に格納されたリファレンス)は, サブルーチンの外側の配列･ハッシュの実体(この場合, `%hash`)を指しているので, サブルーチンの中でデータ構造を書き換えると, 実体にも影響が出てしまいます.

## 練習問題
- 配列とハッシュをそれぞれ1つずつ定義してから, 第1引数に配列のリファレンス, 第2引数にハッシュのリファレンスを受け取り, その中身を出力する(for文などを利用して...), `output_array_and_hash`というサブルーチンを書いてみよう.


# 正規表現

# 正規表現と置換

